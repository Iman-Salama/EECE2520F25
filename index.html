<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonically Related Signals Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
            min-height: 100vh;
            color: white;
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group h3 {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1.1em;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .control-row label {
            min-width: 90px;
            font-weight: 500;
            font-size: 13px;
        }

        .frequency-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .freq-btn {
            padding: 6px 12px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.3s ease;
        }

        .freq-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        .freq-btn.active {
            background: #64ffda;
            color: #1a1a1a;
            border-color: #64ffda;
            box-shadow: 0 2px 8px rgba(100, 255, 218, 0.3);
        }

        .sampling-select {
            padding: 6px 10px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            min-width: 70px;
        }

        .sampling-select option {
            background: #2a2a2a;
            color: white;
        }

        .value-display {
            min-width: 50px;
            text-align: center;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 12px;
        }

        .harmonic-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 10px;
        }

        .harmonic-control {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .harmonic-control h4 {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .checkbox-container label {
            font-size: 12px;
            min-width: auto;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .compact-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .compact-control label {
            min-width: 55px;
            font-size: 11px;
            font-weight: 500;
            flex-shrink: 0;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.2);
            outline: none;
            margin: 0 6px;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }

        .compact-value {
            min-width: 40px;
            text-align: center;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            flex-shrink: 0;
        }

        .plots-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .plot-section {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .plot-section h3 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1.1em;
        }

        .dt-individual-plot {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dt-plot-title {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 6px;
            text-align: center;
            color: #64ffda;
        }

        .dt-plot-canvas {
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        canvas {
            width: 100%;
            height: 180px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .info-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid rgba(255,255,255,0.2);
            margin-top: 15px;
        }

        .formula {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 8px 0;
            border-left: 3px solid #64ffda;
            font-size: 13px;
        }

        .highlight {
            color: #64ffda;
            font-weight: bold;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .info-box {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
        }

        .info-box h4 {
            color: #64ffda;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .info-box div {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .info-box ul {
            font-size: 12px;
        }

        .info-box li {
            margin-bottom: 4px;
        }

        .warning-text {
            color: #ff6b6b;
            font-size: 11px;
            margin-bottom: 6px;
            background: rgba(255, 107, 107, 0.1);
            padding: 4px 6px;
            border-radius: 4px;
            border-left: 2px solid #ff6b6b;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .harmonic-controls {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .harmonic-controls {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
            
            .compact-control {
                gap: 6px;
            }
            
            .compact-control label {
                min-width: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Harmonically Related Signals Simulator</h1>
            <p>Simulation platform for analyzing harmonic signals in continuous-time and discrete-time domains</p>
        </div>

        <div class="main-content">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>⚙️ Fundamental Parameters</h3>
                    <div class="control-row">
                        <label>Frequency:</label>
                        <div class="frequency-buttons" id="frequency-buttons">
                            <!-- Frequency buttons will be generated here -->
                        </div>
                    </div>
                    <div class="control-row">
                        <label>Sampling:</label>
                        <select class="sampling-select" id="sampling-rate">
                            <!-- Sampling rate options will be generated here -->
                        </select>
                        <span class="value-display" id="fs-display">20 Hz</span>
                    </div>
                    <div class="info-box">
                        <h4>📊 Current Settings</h4>
                        <div id="settings-info">
                            <div>Time: <span id="timespan-display">5.0 s</span> | Period: <span id="period-display">1.0 s</span></div>
                            <div>Samples/Period: <span id="samples-display">20</span> | Periods: <span id="periods-display">5</span></div>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>📊 Harmonic Components</h3>
                    <div class="harmonic-controls" id="harmonic-controls">
                        <!-- Harmonic controls will be generated here -->
                    </div>
                </div>
            </div>

            <div class="plots-container">
                <div class="plot-section">
                    <h3>📈 Continuous Time Signal</h3>
                    <canvas id="ct-canvas"></canvas>
                    <div class="legend" id="ct-legend"></div>
                </div>

                <div class="plot-section">
                    <h3>📊 Discrete Time Signals</h3>
                    <div id="dt-plots-container">
                        <!-- Individual DT plots will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>📋 Mathematical Formulation</h3>
            <div class="formula">
                <strong>Continuous Time:</strong><br>
                x(t) = Σ <span class="highlight">A<sub>k</sub></span> cos(k<span class="highlight">ω₀</span>t + <span class="highlight">φ<sub>k</sub></span>)<br>
                where k = 1, 2, 3, ... (harmonic numbers)
            </div>
            <div class="formula">
                <strong>Discrete Time:</strong><br>
                x[n] = Σ <span class="highlight">A<sub>k</sub></span> cos(k<span class="highlight">Ω₀</span>n + <span class="highlight">φ<sub>k</sub></span>)<br>
                where Ω₀ = 2πf₀/f<sub>s</sub> and n = 0, 1, 2, ...
            </div>
            <div class="info-box">
                <h4>🎯 Key Learning Objectives</h4>
                <ul style="margin-left: 15px;">
                    <li><strong>Harmonic Analysis:</strong> Examine individual and combined harmonic components</li>
                    <li><strong>Aliasing Effects:</strong> Observe frequency aliasing when harmonics exceed Nyquist frequency</li>
                    <li><strong>Sampling Theory:</strong> Study the relationship between sampling rate and signal fidelity</li>
                    <li><strong>CT/DT Comparison:</strong> Compare continuous-time and discrete-time signal representations</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        class HarmonicsSimulator {
            constructor() {
                this.f0 = 2; // Fundamental frequency in Hz (1, 2, 3, 4, or 5)
                this.fs = 10; // Sampling frequency (integer multiple of f0)
                this.timeSpan = 5 / this.f0; // Always show 5 periods
                this.harmonics = [
                    {enabled: true, amplitude: 1.0, phase: 0},
                    {enabled: false, amplitude: 0.5, phase: 0},
                    {enabled: false, amplitude: 0.33, phase: 0},
                    {enabled: false, amplitude: 0.25, phase: 0},
                    {enabled: false, amplitude: 0.2, phase: 0}
                ];
                
                this.colors = ['#ff6b6b', '#00d084', '#ff8c42', '#a78bfa', '#ffd93d'];
                this.sumColor = '#ffffff';
                
                this.initializeControls();
                this.setupCanvases();
                this.updatePlots();
            }

            initializeControls() {
                this.createFrequencyButtons();
                this.updateSamplingRates();
                this.createHarmonicControls();
                this.updateSettingsDisplay();
            }

            createFrequencyButtons() {
                const container = document.getElementById('frequency-buttons');
                container.innerHTML = '';
                
                [1, 2, 3, 4, 5].forEach(freq => {
                    const button = document.createElement('button');
                    button.className = `freq-btn ${freq === this.f0 ? 'active' : ''}`;
                    button.textContent = `${freq} Hz`;
                    button.addEventListener('click', () => {
                        this.f0 = freq;
                        this.timeSpan = 5 / this.f0;
                        
                        // Update active button
                        container.querySelectorAll('.freq-btn').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        
                        this.updateSamplingRates();
                        this.updateSettingsDisplay();
                        this.createHarmonicControls();
                        this.createDTCanvases(); // Recreate DT canvases
                        this.updatePlots();
                    });
                    container.appendChild(button);
                });
            }

            updateSamplingRates() {
                const select = document.getElementById('sampling-rate');
                select.innerHTML = '';
                
                // Generate sampling rates that are integer multiples of f0
                const multipliers = [2, 4, 5, 10, 15, 20, 25];
                
                multipliers.forEach(mult => {
                    const fs = mult * this.f0;
                    const option = document.createElement('option');
                    option.value = fs;
                    option.textContent = `${mult}×f₀ (${fs} Hz)`;
                    select.appendChild(option);
                });

                // Set default to 10×f0 if available, otherwise first option
                const defaultFs = this.harmonics.length > 0 && multipliers.includes(10) ? 10 * this.f0 : multipliers[0] * this.f0;
                if (multipliers.includes(this.fs / this.f0)) {
                    select.value = this.fs;
                } else {
                    this.fs = defaultFs;
                    select.value = this.fs;
                }

                select.addEventListener('change', (e) => {
                    this.fs = parseInt(e.target.value);
                    this.updateSettingsDisplay();
                    this.createHarmonicControls(); // Recreate to update Nyquist warnings
                    this.createDTCanvases(); // Recreate DT canvases with new frequency labels
                    this.updatePlots();
                });

                document.getElementById('fs-display').textContent = `${this.fs} Hz`;
            }

            updateSettingsDisplay() {
                const T0 = 1 / this.f0;
                const samplesPerPeriod = this.fs / this.f0;
                
                document.getElementById('timespan-display').textContent = `${this.timeSpan.toFixed(1)} s`;
                document.getElementById('period-display').textContent = `${T0.toFixed(2)} s`;
                document.getElementById('samples-display').textContent = `${samplesPerPeriod}`;
                document.getElementById('periods-display').textContent = `5`;
                document.getElementById('fs-display').textContent = `${this.fs} Hz`;
            }

            createDTCanvases() {
                const container = document.getElementById('dt-plots-container');
                container.innerHTML = '';
                
                this.dtCanvases = [];
                this.dtContexts = [];
                
                // Create canvas for sum signal first
                const sumDiv = document.createElement('div');
                sumDiv.className = 'dt-individual-plot';
                
                const Omega0 = (2 * Math.PI * this.f0 / this.fs);
                const sumTitle = document.createElement('div');
                sumTitle.className = 'dt-plot-title';
                sumTitle.innerHTML = `<strong>Sum Signal</strong> (Ω₀ = ${Omega0.toFixed(3)} rad/sample)`;
                sumDiv.appendChild(sumTitle);
                
                const sumCanvas = document.createElement('canvas');
                sumCanvas.className = 'dt-plot-canvas';
                sumCanvas.id = 'dt-sum-canvas';
                sumDiv.appendChild(sumCanvas);
                container.appendChild(sumDiv);
                
                // Setup sum canvas
                const setCanvasSize = (canvas) => {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width * window.devicePixelRatio;
                    canvas.height = rect.height * window.devicePixelRatio;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                };
                
                setCanvasSize(sumCanvas);
                this.dtSumCanvas = sumCanvas;
                this.dtSumCtx = sumCanvas.getContext('2d');
                
                // Create individual harmonic canvases
                this.harmonics.forEach((harmonic, index) => {
                    if (!harmonic.enabled) return;
                    
                    const harmonicDiv = document.createElement('div');
                    harmonicDiv.className = 'dt-individual-plot';
                    
                    const harmonicNum = index + 1;
                    const freq = this.f0 * harmonicNum;
                    const Omega = (2 * Math.PI * freq / this.fs);
                    const nyquist = this.fs / 2;
                    const isAboveNyquist = freq > nyquist;
                    
                    // Calculate effective (aliased) frequency and Omega
                    let effectiveFreq = freq;
                    let effectiveOmega = Omega;
                    if (isAboveNyquist) {
                        effectiveFreq = freq - this.fs * Math.floor(freq / this.fs + 0.5);
                        effectiveFreq = Math.abs(effectiveFreq);
                        effectiveOmega = 2 * Math.PI * effectiveFreq / this.fs;
                    }
                    
                    const title = document.createElement('div');
                    title.className = 'dt-plot-title';
                    title.style.color = this.colors[index];
                    
                    if (isAboveNyquist) {
                        title.innerHTML = `H${harmonicNum}: Ω = ${Omega.toFixed(3)} → ${effectiveOmega.toFixed(3)} rad/sample (aliased from ${freq.toFixed(1)} Hz to ${effectiveFreq.toFixed(1)} Hz) ⚠️`;
                        title.style.textShadow = '0 0 10px #ff6b6b';
                    } else {
                        title.innerHTML = `H${harmonicNum}: Ω = ${Omega.toFixed(3)} rad/sample (${freq.toFixed(1)} Hz)`;
                    }
                    
                    harmonicDiv.appendChild(title);
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'dt-plot-canvas';
                    canvas.id = `dt-harmonic-${index}`;
                    harmonicDiv.appendChild(canvas);
                    container.appendChild(harmonicDiv);
                    
                    setCanvasSize(canvas);
                    this.dtCanvases[index] = canvas;
                    this.dtContexts[index] = canvas.getContext('2d');
                });
            }

            setupCanvases() {
                this.ctCanvas = document.getElementById('ct-canvas');
                this.ctCtx = this.ctCanvas.getContext('2d');
                
                // Set canvas resolution for CT canvas
                const setCanvasSize = (canvas) => {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width * window.devicePixelRatio;
                    canvas.height = rect.height * window.devicePixelRatio;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                };
                
                setCanvasSize(this.ctCanvas);
                
                // Create DT canvases dynamically
                this.createDTCanvases();
            }

            createHarmonicControls() {
                const container = document.getElementById('harmonic-controls');
                container.innerHTML = '';

                this.harmonics.forEach((harmonic, index) => {
                    const harmonicDiv = document.createElement('div');
                    harmonicDiv.className = 'harmonic-control';
                    
                    const harmonicNum = index + 1;
                    const freq = this.f0 * harmonicNum;
                    const nyquist = this.fs / 2;
                    const isAboveNyquist = freq > nyquist;
                    
                    // Calculate aliased frequency if above Nyquist
                    let aliasedFreq = freq;
                    if (isAboveNyquist) {
                        // Simple aliasing calculation: freq - fs * floor(freq/fs + 0.5)
                        aliasedFreq = freq - this.fs * Math.floor(freq / this.fs + 0.5);
                        aliasedFreq = Math.abs(aliasedFreq);
                    }
                    
                    harmonicDiv.innerHTML = `
                        <h4 style="color: ${this.colors[index]}${isAboveNyquist ? '; text-shadow: 0 0 10px #ff6b6b' : ''}">
                            📊 H${harmonicNum} (${freq.toFixed(1)} Hz)
                            ${isAboveNyquist ? ' ⚠️' : ''}
                        </h4>
                        ${isAboveNyquist ? `<div class="warning-text">⚠️ Above Nyquist (${nyquist} Hz)!<br>Will alias to ${aliasedFreq.toFixed(1)} Hz</div>` : ''}
                        <div class="checkbox-container">
                            <input type="checkbox" id="enable-${index}" ${harmonic.enabled ? 'checked' : ''}>
                            <label for="enable-${index}">Enable</label>
                        </div>
                        <div class="compact-control">
                            <label>Amp:</label>
                            <input type="range" id="amp-${index}" min="0" max="1" step="0.05" value="${harmonic.amplitude}">
                            <span class="compact-value" id="amp-value-${index}">${harmonic.amplitude.toFixed(2)}</span>
                        </div>
                        <div class="compact-control">
                            <label>Phase:</label>
                            <input type="range" id="phase-${index}" min="0" max="360" step="15" value="${harmonic.phase}">
                            <span class="compact-value" id="phase-value-${index}">${harmonic.phase}°</span>
                        </div>
                    `;
                    
                    container.appendChild(harmonicDiv);

                    // Add event listeners for all harmonics
                    document.getElementById(`enable-${index}`).addEventListener('change', (e) => {
                        this.harmonics[index].enabled = e.target.checked;
                        this.createDTCanvases(); // Recreate DT canvases when harmonics change
                        this.updatePlots();
                    });

                    document.getElementById(`amp-${index}`).addEventListener('input', (e) => {
                        this.harmonics[index].amplitude = parseFloat(e.target.value);
                        document.getElementById(`amp-value-${index}`).textContent = parseFloat(e.target.value).toFixed(2);
                        this.updatePlots();
                    });

                    document.getElementById(`phase-${index}`).addEventListener('input', (e) => {
                        this.harmonics[index].phase = parseFloat(e.target.value);
                        document.getElementById(`phase-value-${index}`).textContent = e.target.value + '°';
                        this.updatePlots();
                    });
                });
            }

            generateContinuousSignal() {
                const numPoints = 2000;
                const dt = this.timeSpan / numPoints;
                const t = Array.from({length: numPoints}, (_, i) => i * dt);
                
                // Generate individual harmonics
                const harmonicSignals = this.harmonics.map((harmonic, index) => {
                    if (!harmonic.enabled) return null;
                    
                    const k = index + 1;
                    const freq = this.f0 * k;
                    const omega = 2 * Math.PI * freq;
                    const phaseRad = harmonic.phase * Math.PI / 180;
                    
                    return t.map(time => harmonic.amplitude * Math.cos(omega * time + phaseRad));
                });
                
                // Generate sum signal
                const sumSignal = t.map((_, i) => {
                    return harmonicSignals.reduce((sum, signal) => {
                        return sum + (signal ? signal[i] : 0);
                    }, 0);
                });
                
                return {
                    t: t,
                    harmonics: harmonicSignals,
                    sum: sumSignal
                };
            }

            generateDiscreteSignal() {
                const Ts = 1 / this.fs;
                const numSamples = Math.floor(this.timeSpan * this.fs);
                const n = Array.from({length: numSamples}, (_, i) => i);
                const t = n.map(sample => sample * Ts);
                
                // Generate individual harmonics
                const harmonicSignals = this.harmonics.map((harmonic, index) => {
                    if (!harmonic.enabled) return null;
                    
                    const k = index + 1;
                    const freq = this.f0 * k;
                    
                    // Calculate aliased frequency for discrete time
                    let effectiveFreq = freq;
                    if (freq > this.fs / 2) {
                        // Calculate aliased frequency
                        effectiveFreq = freq - this.fs * Math.floor(freq / this.fs + 0.5);
                        effectiveFreq = Math.abs(effectiveFreq);
                    }
                    
                    const Omega = 2 * Math.PI * effectiveFreq / this.fs;
                    const phaseRad = harmonic.phase * Math.PI / 180;
                    
                    return n.map(sample => harmonic.amplitude * Math.cos(Omega * sample + phaseRad));
                });
                
                // Generate sum signal
                const sumSignal = n.map((_, i) => {
                    return harmonicSignals.reduce((sum, signal) => {
                        return sum + (signal ? signal[i] : 0);
                    }, 0);
                });
                
                return {
                    t: t,
                    n: n,
                    harmonics: harmonicSignals,
                    sum: sumSignal
                };
            }

            plotContinuous() {
                const signals = this.generateContinuousSignal();
                const canvas = this.ctCanvas;
                const ctx = this.ctCtx;
                const rect = canvas.getBoundingClientRect();
                
                ctx.clearRect(0, 0, rect.width, rect.height);
                
                // Setup plotting parameters
                const margin = 35;
                const plotWidth = rect.width - 2 * margin;
                const plotHeight = rect.height - 2 * margin;
                
                // Find amplitude range
                const allSignals = [signals.sum, ...signals.harmonics.filter(s => s !== null)].flat();
                const maxAmp = Math.max(...allSignals.map(Math.abs));
                const ampRange = Math.max(maxAmp * 1.1, 0.1);
                
                // Draw grid and period markers
                this.drawGrid(ctx, margin, plotWidth, plotHeight, this.timeSpan, ampRange, false, false, null);
                this.drawPeriodMarkers(ctx, margin, plotWidth, plotHeight);
                
                // Plot individual harmonics
                signals.harmonics.forEach((signal, index) => {
                    if (signal) {
                        this.drawContinuousSignal(ctx, signals.t, signal, this.colors[index], 
                                                margin, plotWidth, plotHeight, this.timeSpan, ampRange, 1);
                    }
                });
                
                // Plot sum signal (thicker line)
                this.drawContinuousSignal(ctx, signals.t, signals.sum, this.sumColor, 
                                        margin, plotWidth, plotHeight, this.timeSpan, ampRange, 3);
                
                // Update legend
                this.updateLegend('ct-legend', signals);
            }

            plotDiscrete() {
                const signals = this.generateDiscreteSignal();
                
                // Find amplitude range for consistent scaling
                const allSignals = [signals.sum, ...signals.harmonics.filter(s => s !== null)].flat();
                const maxAmp = Math.max(...allSignals.map(Math.abs));
                const ampRange = Math.max(maxAmp * 1.1, 0.1);
                
                // Plot sum signal
                this.plotIndividualDTSignal(this.dtSumCtx, this.dtSumCanvas, signals.t, signals.sum, this.sumColor, ampRange, true);
                
                // Plot individual harmonics
                signals.harmonics.forEach((signal, index) => {
                    if (signal && this.harmonics[index].enabled && this.dtContexts[index]) {
                        this.plotIndividualDTSignal(this.dtContexts[index], this.dtCanvases[index], signals.t, signal, this.colors[index], ampRange);
                    }
                });
            }

            plotIndividualDTSignal(ctx, canvas, t, signal, color, ampRange, isSum = false) {
                const rect = canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, rect.width, rect.height);
                
                // Setup plotting parameters
                const margin = 25;
                const plotWidth = rect.width - 2 * margin;
                const plotHeight = rect.height - 2 * margin;
                
                // Draw grid
                this.drawGrid(ctx, margin, plotWidth, plotHeight, this.timeSpan, ampRange, true, true, t);
                
                // Draw period markers
                this.drawPeriodMarkers(ctx, margin, plotWidth, plotHeight);
                
                // Draw signal
                this.drawDiscreteSignal(ctx, t, signal, color, margin, plotWidth, plotHeight, this.timeSpan, ampRange, isSum);
            }

            drawPeriodMarkers(ctx, margin, width, height) {
                const T0 = 1 / this.f0;
                ctx.strokeStyle = 'rgba(100, 255, 218, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                
                for (let period = 1; period <= 4; period++) {
                    const x = margin + (period * T0 / this.timeSpan) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, margin);
                    ctx.lineTo(x, margin + height);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }

            drawGrid(ctx, margin, width, height, timeSpan, ampRange, isSmall = false, isDiscrete = false, discreteTimeArray = null) {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                
                // Vertical grid lines (time)
                const timeStep = timeSpan / 10;
                for (let i = 0; i <= 10; i++) {
                    const x = margin + (i / 10) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, margin);
                    ctx.lineTo(x, margin + height);
                    ctx.stroke();
                }
                
                // Horizontal grid lines (amplitude)
                const gridLines = isSmall ? 4 : 6;
                for (let i = 0; i <= gridLines; i++) {
                    const y = margin + (i / gridLines) * height;
                    ctx.beginPath();
                    ctx.moveTo(margin, y);
                    ctx.lineTo(margin + width, y);
                    ctx.stroke();
                }
                
                // Axes
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1.5;
                
                // X-axis (at y=0)
                const zeroY = margin + height/2;
                ctx.beginPath();
                ctx.moveTo(margin, zeroY);
                ctx.lineTo(margin + width, zeroY);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, margin + height);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = isSmall ? '10px Arial' : '12px Arial';
                ctx.textAlign = 'center';
                
                // Time labels
                if (isDiscrete && discreteTimeArray) {
                    // For discrete-time signals, show both time (s) and sample number (n)
                    const maxSamples = discreteTimeArray.length;
                    const sampleStep = Math.max(1, Math.floor(maxSamples / 8)); // Show ~8 labels max
                    
                    for (let i = 0; i < maxSamples; i += sampleStep) {
                        const x = margin + (discreteTimeArray[i] / timeSpan) * width;
                        const timeLabel = discreteTimeArray[i].toFixed(2) + 's';
                        const sampleLabel = `n=${i}`;
                        
                        // Draw time in seconds (top label)
                        ctx.fillText(timeLabel, x, margin + height + (isSmall ? 15 : 18));
                        // Draw sample number (bottom label)
                        ctx.fillStyle = 'rgba(100, 255, 218, 0.8)'; // Cyan color for sample numbers
                        ctx.fillText(sampleLabel, x, margin + height + (isSmall ? 25 : 30));
                        ctx.fillStyle = 'rgba(255,255,255,0.8)'; // Reset color
                    }
                } else {
                    // For continuous-time signals, show more frequent time labels
                    const numLabels = isSmall ? 6 : 10;
                    const labelStep = timeSpan / numLabels;
                    
                    for (let i = 0; i <= numLabels; i++) {
                        const time = i * labelStep;
                        const x = margin + (time / timeSpan) * width;
                        ctx.fillText(time.toFixed(1) + 's', x, margin + height + (isSmall ? 15 : 18));
                    }
                }
                
                // Amplitude labels
                ctx.textAlign = 'right';
                const ampLines = isSmall ? 2 : 3;
                for (let i = 0; i <= ampLines; i++) {
                    const y = margin + height - (i / ampLines) * height + 4;
                    const amp = ((i / ampLines) - 0.5) * 2 * ampRange;
                    ctx.fillText(amp.toFixed(1), margin - (isSmall ? 5 : 8), y);
                }
            }

            drawContinuousSignal(ctx, t, signal, color, margin, width, height, timeSpan, ampRange, lineWidth = 2) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                
                for (let i = 0; i < t.length; i++) {
                    const x = margin + (t[i] / timeSpan) * width;
                    const y = margin + height/2 - (signal[i] / ampRange) * height/2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }

            drawDiscreteSignal(ctx, t, signal, color, margin, width, height, timeSpan, ampRange, isSum = false) {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = isSum ? 2.5 : 1.5;
                
                for (let i = 0; i < t.length; i++) {
                    const x = margin + (t[i] / timeSpan) * width;
                    const y = margin + height/2 - (signal[i] / ampRange) * height/2;
                    const zeroY = margin + height/2;
                    
                    // Draw stem
                    ctx.beginPath();
                    ctx.moveTo(x, zeroY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.beginPath();
                    ctx.arc(x, y, isSum ? 3.5 : 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            updateLegend(legendId, signals) {
                const legend = document.getElementById(legendId);
                legend.innerHTML = '';
                
                // Add harmonic legends
                this.harmonics.forEach((harmonic, index) => {
                    if (harmonic.enabled && signals.harmonics[index]) {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.innerHTML = `
                            <div class="legend-color" style="background-color: ${this.colors[index]}"></div>
                            <span>H${index + 1} (${(this.f0 * (index + 1)).toFixed(1)} Hz)</span>
                        `;
                        legend.appendChild(item);
                    }
                });
                
                // Add sum legend
                const sumItem = document.createElement('div');
                sumItem.className = 'legend-item';
                sumItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${this.sumColor}"></div>
                    <span><strong>Sum</strong></span>
                `;
                legend.appendChild(sumItem);
            }

            updatePlots() {
                this.plotContinuous();
                this.plotDiscrete();
            }
        }

        // Initialize the simulator when the page loads
        window.addEventListener('load', () => {
            window.simulator = new HarmonicsSimulator();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(() => {
                const simulator = window.simulator;
                if (simulator) {
                    simulator.setupCanvases();
                    simulator.createDTCanvases(); // Recreate DT canvases on resize
                    simulator.updatePlots();
                }
            }, 100);
        });
    </script>
</body>
</html>
